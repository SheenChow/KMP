/*朴素的模式匹配算法*/

/*返回子串T在主串S中第pos个字符字符之后的位置，若不存在，则函数返回值为0*/

/*T非空，且1<=pos<=StrLength(S)/S[0]. 注：我觉得此时可以把限制条件进一步缩小，变为1 <= pos <= S[0] -T[0] + 1 */

int Index(String S, String T, int pos)
{
	/*i用于表示主串s中当前位置的下标，若pos不为1，则从pos位置开始匹配*/
	int i = pos;

	/*j用于表示子串T中当前位置的下标值*/
	int j = 1;

	while(i <= S[0] && j <= T[0])
	{
		/*两字母相等，则继续*/
		if (S[i] == T[j])
		{

			i++;

			j++;

		} 
		/*指针后退，重新开始匹配*/
		else 
		{
            /*i退回到上次匹配首位的下一位*/
			i = i - j + 2;
            
            /*j退回到子串T的首位*/
			j = 1;

		}
	}

	if (j == T[0])

		return i - T[0];

	else

		return 0;
}

总结：朴素的模式匹配算法中最好的情况下时间复杂度为O(m+n),最坏的情况下则需要O((n - m + 1) * m)
      按照大O原则，化简后时间复杂度为O(m * n)